#
# [file:#lines]
# desc
#

#[zookd.c:1612]
#description goes here. for example, the 'buf' variable can be
#overwritten by the 'msg' variable because ...
#
#    <paste offending line(s) of code here>
#
#[http.c:1512]
#another description.
#
#    <paste offending line(s) of code here>
#
# many more come here

[http.c:438]
The url_decode function does not perform bounds checking on the size of the dst array. As long as src still has valid characters, url_decode will keep copying them into dst and will eventually overflow the buffer. I tested this attack by making a request path with 3000+ chars since reqpath as defined in [zookd.c:65] is only 2048 bytes.

<CODE>

[http.c:283]
strcat is an exploitable function. The buffer pn is only 1024 bytes, but name may be of any length. In this case, name is set as the value of getenv("REQUEST_URI") in [zookfs.c:47]. This is risky because pn is right next to a fn pointer handler. This is actually vulnerable to 2 types of exploits - a classic stack overflow as well as overwriting the fn pointer immediately adjacent to it. 

[http.c:95]
sprintf is a vulnerable function since it does not do bounds checking. If I attack with a long request method, then I can copy into *envp(=*env) enough bytes to access memory outside of *env which is 8129 bytes, as declared in [zookd.c:63] and passed to http_request_line in [zookd.c:70]. However this will be a heap attack not a stack attack since env is declared as static. 

[http.c:96]
Similar to the previous attack except this time using the SERVER_PROTOCOL to overflow the buffer and write to adjacent memory on the heap. Again because sprintf does not do any bounds checking. 
