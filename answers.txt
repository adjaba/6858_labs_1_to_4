## Place your answers here.

exploit-2a.py attacks via the url_decode function that is called in http_request_line function[http.c:106] by providing a very long request path, enough to overflow the buffer reqpath and corrupt memory causing a segfault.

exploit-2b.py attacks via the function pointer defined in http_serve [http.c:276] called handler. By providing a long value to the name arg (via the ) the strcat function, which does not check bounds, can overwrite past the end of the pn buffer and into the handler fn pointer. With an invalid fn pointer address, the program segfaults when handler is invoked in :297. 

exploit-3.py attacks via the http_request_headers() method. That method parses the HTTP headers. It calls the vulnerable url_decode function to copy a decoded string into its value buf. The value buf is overflowed as to overwrite the saved eip on the stack. By placing the exploit shell code into the buff, and changing the saved eip to the start of the shellcode in the buf, I can run the arbitrary code. An additional complication is that the function runs in an infinite loop. Since the saved eip is not popped and executed until the fn returns, I needed to force the loop to break early and cause the function to return prematurely. I accomplished this by continuing to set memory above the saved eip in the stack to the value -1. This would result in the fd (which was an arg to http_request_headers) being passed to http_read_line to be invalid and the function to return based on [http.c:130-131]. This was very difficult to use gdb on, since I had also corruped the saved esp and ebp in the process, which gdb may have used toaccess some debug info. I used strace -fp $(pgrep zookfs-exstack) to follow the execution of the exploit without GDB running. Much thanks to TA Steven for helping overcome so many issues with this exploit.   
